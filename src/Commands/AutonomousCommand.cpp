// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "AutonomousCommand.h"
#include "lFirstToteLevel.h"
#include "lPIDFloor.h"

AutonomousCommand::AutonomousCommand() {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	counter = 0;
	turnedCounter = 0;
	turned = false;
	testTime = 0;
}

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() {

	Robot::driveTrain->gyro->Reset();
	RobotMap::clamppiston->Set(false);
	counter = 0;
	turnedCounter = 0;
	turned = false;
	testTime = 0;


}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {

	int autonomousmode = 1;


	switch(autonomousmode)
	{
	case 1:
		Autonomous1();
		break;
	case 2:

		break;
	case 3:

		break;
	}



}


// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished() {
	return false;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {
	
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {

}
void AutonomousCommand::Autonomous1()
{
	switch (turnedCounter)
	{
		//if the robot hasn't turned yet
		//aka the beginning position
		case 0:
		{
			//grab the TOTE
			if (counter <=10)
				RobotMap::clamppiston->Set(true);

			//move the TOTE to the first level (about 7in off the ground)
			else if(counter <= 50)
				(new lFirstToteLevel)->Start();

			//move the robot back
			else if(counter <=80)
				Robot::driveTrain->mecanum->MecanumDrive_Cartesian(0,.2,0);

			//stop and turn the robot counter clockwise
			else if(counter <= 90)
				Robot::driveTrain->mecanum->MecanumDrive_Cartesian(0,0.0,0);
			else if(turned == false)
				turned = Robot::driveTrain->TurnTo(90);

			break;
		}

		//if the robot's turned once
		//aka the robot's turned towards the autozone
		case 1:
		{
			//move the robot forward (towards the autozone)
			if(counter < 160 && counter > 10)
				Robot::driveTrain->mecanum->MecanumDrive_Cartesian(0,-.3,0);

			//stop and turn the robot clockwise
			else if(counter < 170)
				Robot::driveTrain->mecanum->MecanumDrive_Cartesian(0,0,0);
			else if(turned == false)
				turned = Robot::driveTrain->TurnTo(0);
			break;
		}

		//if the robot's turned twice
		//aka when the robot's in the autozone
		case 2:
		{
			if(counter < 80)
			{
				(new lPIDFloor)->Start();
			}
			//drop the TOTE
			else if(counter < 110)
				RobotMap::clamppiston->Set(false);

			//back up out of the way
			else if(counter < 125)
				Robot::driveTrain->mecanum->MecanumDrive_Cartesian(0,0.2,0);
			break;
		}

	}
	//reset the counter when you turn the robot
	if(turned == true)
	{
		turned = false;
		turnedCounter ++;
		counter = 0;
	}
	testTime = time(NULL);
	printf("Time : %i\n", testTime);
	counter ++;
}
